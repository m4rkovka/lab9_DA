\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{color}
\usepackage[table]{xcolor}
\usepackage{tikz}
\usepackage{ulem}
\usepackage[russian]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{indentfirst}

% Оригиналный шаблон: http://k806.ru/dalabs/da-report-template-2012.tex

\begin{document}

\thispagestyle{empty}
\begin{center}
    {\Large Московский авиационный институт\\ (национальный исследовательский университет)}

    \vspace{48pt}

    {\large Факультет информационных технологий и прикладной математики}

    \vspace{36pt}

    {\large Кафедра вычислительной математики и~программирования}

    \vspace{48pt}
    
    Лабораторная работа \textnumero 9 по курсу \enquote{Дискретный анализ}

\end{center}
    
    \vspace{72pt}
    
    \begin{flushright}
    \begin{tabular}{rl}
    Студент: & А.\,Н. Марков \\
    Преподаватель: & Н.\,А. Зацепин \\
    Группа: & М8О-308Б \\
    Дата: & \\
    Оценка: & \\
    Подпись: & \\
    \end{tabular}
    \end{flushright}
    
    \vfill
    
    \begin{center}
    \bfseries
    Москва, \the\year
\end{center}

\newpage

\subsection*{Условие}
\begin{enumerate}
\item Общая постановка задачи 

Разработать программу на языке C или C++, реализующую указанный алгоритм согласно заданию.

\item Вариант задания 

Вариант 4. Задан взвешенный неориентированный граф, состоящий из \textbf{n} вершин и \textbf{m} ребер. Вершины пронумерованы целыми числами \textbf{от 1 до n}. Необходимо найти длину кратчайшего пути из вершины с номером \textbf{start} в вершину с номером \textbf{finish} при помощи алгоритма Дейкстры. Длина пути равна сумме весов ребер на этом пути. Граф не содержит петель и кратных ребер.

\item Формат входных данных

В первой строке заданы $1 \leq n \leq 10^5$, $1 \leq m \leq 10^5$, $1 \leq start \leq n$ и $1 \leq finish \leq n$. В следующих m строках записаны ребра. Каждая строка содержит три числа – номера вершин, соединенных ребром, и вес данного ребра. Вес ребра – целое число от 0 до $10^9$.

\item Формат результата

Необходимо вывести одно число – длину кратчайшего пути между указанными вершинами. Если пути между указанными вершинами не существует, следует вывести строку "No solution" (без кавычек).

\end{enumerate}

\subsection*{Метод решения}

Алгоритм Дейкстры предназначен для поиска кратчайшего пути из вершины-истока до всех остальных вершин графа, но этот алгоритм легко преобразуется в алгоритм поиска кратчайшего пути из одной вершины в другую. Алгоритм Дейкстры применим только, когда веса ребер графа неотрицательны.

Основная идея данного алгоритма в том, что алгоритме Дейкстры поддерживается множество вершин S, для которых уже вычислены окончательные веса кратчайших путей к ним из истока s. Поочередно выбирается вершина $u \in V - S$, которой на данном этапе соответствует минимальная оценка кратчайшего пути. После добавления этой вершины u в множество S проводится ослабление всех исходящих из нее ребер.

В моей реализации множество вершин S - это массив из n элементов, в котором в i-ой ячейке хранится расстояние для i-ой вершины. Множество $V - S$ в моей реализации представляется очередь с приоритетами.

Анализ сложности алгоритма. Т.к. в моей реализации я использовал очередь приоритетов std::priority\_queue из стандартной библиотеки C++, в которой отсутствует функция изменения приоритета одного из элементов очереди, то всего итераций в цикле for O(m), а значит, может быть вставлено в очередь приоритетов O(m) элементов. Тогда получается, что всего может быть O(m) итераций цикла while. Итераций цикла for будет O(m), поскольку в теле цикла while не будут рассматриваться вершины, в которых уже найден кратчайший путь.
Нахождение минимального элемента в очереди приоритетов $O(1)$. Операции вставки и удаления элементов из очереди приоритетов имеют сложность $O(log(m))$. Итоговая временная сложность алгоритма Дейкстры в данной реализации: $O(m * log(m))$. Если бы использовалась реализация очереди приоритетов, в которой была бы функция изменения приоритета элемента очереди, то временная сложность была бы равна $O((n + m) * log(n))$. Сложность по памяти в моей реализации: $O(n)$ памяти для хранения расстояний от истока до другой вершины, $O(m)$ памяти для хранения очереди с приоритетами. Итоговая сложность по памяти $O(n + m)$.


\subsection*{Описание программы}

Проект состоит из 3 файлов:
\begin{itemize}
    \item main.cpp - главный файл, в котором реализована функция main
    \item graph.hpp - заголовочный файл, в котором находятся объявления классов ребра графа и графа.
    \item graph.cpp - файл, в котором содержатся реализации методов классов вершины дерева и суффиксного дерева.
\end{itemize}
\subsection*{Дневник отладки}

Программа зашла на чекер с первой попытки.

\subsection*{Тест производительности}

Тесты сгенерированы таким обрзом, что количество ребер графа равно количеству вершин графа, умноженному на 4.

\begin{tikzpicture}
	\begin{axis}[ylabel=Время в мкс,xlabel=Количество вершин графа, width=15.5cm, height=10cm,grid=both]
	\addplot coordinates {
	    ( 10000, 33219 )
	    ( 9000, 29698 )
	    ( 8000, 26229 )
	    ( 7000, 22524 )
	    ( 6000, 19111 )
	    ( 5000, 15277 )
	    ( 4000, 12370)
	    ( 3000, 9006 )
	    ( 2000, 5696 )
	    ( 1000, 2688 )
	    ( 500, 1683 )
		( 100, 368 )};
	\end{axis}

\end{tikzpicture}

\subsection*{Выводы}

Графы обширно применяются в современном мире: прокладывание дорог, маршрутов, и, вообще, повсеместно в логистике. Частный случай графа - дерево, имеет широкое применение в информатике. 

Алгоритм Дейкстры поиска кратчайшего пути от исходной вершины оказался не очень сложным. Недостатком моей программы является не очень хорошая реализация: я использовал очередь с приоритетами из стандартной библиотеки, но данная реализация не может обновлять приоритет для некоторого нужного элемента, из-за этого окончательная временная сложность получилась $O(m * log(m))$. Чтобы добиться сложности $O((n + m) * log(n))$, необходимо реализовать собственную очередь с приоритетами.

\end{document}